# Question

[3sum](https://leetcode.cn/problems/3sum/)



# Answer

> solution

1.  **预处理：排序数组 (O(N log N))。**
    *   这是解决问题的**基石**。对数组进行排序后，可以利用其有序性进行高效的查找（双指针）和去重。
    *   **理由：**
        *   有序数组使得我们可以通过移动指针来调整和的大小：`low` 指针向右移动会增大和，`high` 指针向左移动会减小和。
        *   有序数组使得去重变得非常容易：只需比较相邻元素即可。

2.  **降维：固定第一个数 (外层循环 O(N))。**
    *   遍历数组，用一个指针 `i` 固定第一个数 `nums[i]`。
    *   **优化/剪枝：**
        *   如果 `nums[i]` 在排序后已经大于 `0`，则 `nums[i]` 之后的数都会大于等于 `nums[i]`，它们的和不可能为 `0` (因为至少还需要两个非负数)。所以可以提前终止循环。
        *   **去重：** 如果当前的 `nums[i]` 与前一个 `nums[i-1]` 相同，则跳过当前 `i` 的迭代。因为 `nums[i-1]` 已经作为第一个数找到了所有可能的三元组，再用 `nums[i]` 只会产生重复解。
    *   **理由：** 将 `a + b + c = 0` 转换为 `b + c = -a`。问题从“三数之和”降维为“两数之和”，且需要在 `nums[i+1]` 到 `nums[N-1]` 的范围内寻找 `b` 和 `c`，使它们的和为 `-nums[i]`。

3.  **核心：两数之和的双指针查找 (内层循环 O(N))。**
    *   在固定了 `nums[i]` 之后，设置两个指针 `j` (从 `i+1` 开始) 和 `k` (从数组末尾 `N-1` 开始)。
    *   在一个 `while (j < k)` 循环中，不断计算 `current_sum = nums[j] + nums[k]`。
    *   **决策逻辑：**
        *   如果 `current_sum < -nums[i]` (即 `nums[i] + nums[j] + nums[k] < 0`)：说明和太小了，需要增大。将 `j` 指针向右移动 (`j++`)，尝试更大的 `b` 值。
        *   如果 `current_sum > -nums[i]` (即 `nums[i] + nums[j] + nums[k] > 0`)：说明和太大了，需要减小。将 `k` 指针向左移动 (`k--`)，尝试更小的 `c` 值。
        *   如果 `current_sum == -nums[i]` (即 `nums[i] + nums[j] + nums[k] == 0`)：找到了一个有效的三元组 `(nums[i], nums[j], nums[k])`。
            *   将其添加到结果列表中。
            *   **去重：** 找到一个解后，必须同时移动 `j` 和 `k` 指针。并且，为了避免重复的三元组，需要继续移动 `j` 和 `k`，跳过所有与 `nums[j]` 和 `nums[k]` 相同的相邻元素。例如，`while (j < k && nums[j] == nums[j-1]) j++;` 和 `while (j < k && nums[k] == nums[k+1]) k--;`。
    *   **理由：** 双指针在排序数组中寻找特定和的元素对，效率极高。去重逻辑确保了结果的唯一性。

**总结：三数之和的核心思路就是将问题分解：先用 O(N log N) 排序，然后用一个 O(N) 的循环固定第一个元素，剩下的 O(N) 范围内的“两数之和”问题通过 O(N) 的双指针解决，总时间复杂度为 O(N^2)。每一步都严格进行去重和剪枝，以保证效率和结果的唯一性。**

### Way Of C

> source code

```c
typedef struct {
    int **triplets;
    int count;
    int capacity;
} ResultList;

void init_ResultList(ResultList *list, int initial_capacity) {
    list->triplets = (int **)malloc(initial_capacity * sizeof(int *));
    if (list->triplets == NULL) {
        fprintf(stderr, "Err");
        exit(EXIT_FAILURE);
    }
    list->count = 0;
    list->capacity = initial_capacity;
}

void expand_ResultList(ResultList *list) {
    list->capacity *= 2;
    list->triplets = (int **)realloc(list->triplets, list->capacity * sizeof(int *));
    if (list->triplets == NULL) {
        fprintf(stderr, "Err");
        exit(EXIT_FAILURE);        
    }
}

void add_triplet_to_ResultList(ResultList *list, int a, int b, int c) {
    if (list->count >= list->capacity) expand_ResultList(list);
    int *triplet = (int *)malloc(3 * sizeof(int));
    if (triplet == NULL) {
        fprintf(stderr, "Err");
        exit(EXIT_FAILURE);
    }
    triplet[0] = a;
    triplet[1] = b;
    triplet[2] = c;
    list->triplets[list->count++] = triplet;
}

void free_ResultList(ResultList *list) {
    for (int i = 0; i < list->count; ++i) free(list->triplets[i]);
    free(list->triplets);
}

int compare_ints(const void *a, const void *b) {
    return (*(const int *)a - *(const int *)b);
}

static void twoSum(const int *nums, int low, int high, int target, ResultList *result_list, int first_val) {
    while (low < high) {
        long long sum = (long long)nums[low] + nums[high];
        if (sum < target) ++low;
        else if (sum > target) --high;
        else {
            add_triplet_to_ResultList(result_list, first_val, nums[low], nums[high]);
            ++low;
            while (low < high && nums[low] == nums[low - 1]) ++low;
            --high;
            while (low < high && nums[high] == nums[high + 1]) --high;
        }
    }
}

int **threeSum(int *nums, int numsSize, int *returnSize, int **returnColumnSizes) {
    if (nums == NULL || numsSize < 3) {
        *returnSize = 0;
        *returnColumnSizes = NULL;
        return NULL;
    }

    qsort(nums, numsSize, sizeof(int), compare_ints);

    ResultList result_list;
    init_ResultList(&result_list, 10);

    for (int i = 0; i < numsSize - 2; ++i) {
        if (nums[i] > 0) break;
        if (i > 0 && nums[i] == nums[i - 1]) continue;
        twoSum(nums, i + 1, numsSize - 1, -nums[i], &result_list, nums[i]);
    }

    *returnSize = result_list.count;
    if (result_list.count > 0) {
        *returnColumnSizes = (int *)malloc(result_list.count * sizeof(int));
        if (*returnColumnSizes == NULL) {
            fprintf(stderr, "Err");
            free_ResultList(&result_list);
            exit(EXIT_FAILURE);            
        }
        for (int i = 0; i < result_list.count; ++i) (*returnColumnSizes)[i] = 3;
    }
    else *returnColumnSizes = NULL;

    int **final_result = result_list.triplets;

    if (result_list.count == 0) {
        free(final_result);
        return NULL;
    }

    return final_result;
}
```

---

### Way Of C++

> source code

```c++
class Solution {
public:
    vector<vector<int>> threeSum(vector<int>& nums) {
        vector<vector<int>> res;
        if (nums.size() >= 3) {
            sort(nums.begin(), nums.end());
            for (int i = 0; i < nums.size() - 2; ++i) {
                if (i > 0 && nums[i - 1] == nums[i]) continue;
                twoSum(nums.begin() + i + 1, nums.end() - 1, -nums[i], res);
            }
        }
        return res;
    }
private:
    void twoSum(vector<int>::iterator low, vector<int>::iterator high, int target, vector<vector<int>> &res) {
        while (low < high) {
            int sum = *low + *high;
            if (sum < target) ++low;
            else if (sum > target) --high;
            else {
                res.push_back(vector<int> {-target, *low, *high});
                while (++low < high && *low == *(low - 1)) {}
                while (low < high-- && *high == *(high + 1)) {}
            }
        }
    }
};
```
