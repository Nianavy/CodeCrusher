# Question

[4sum](https://leetcode.cn/problems/4sum/)



# Answer

> solution


解决 `k-Sum` 问题的核心思路是**递归降维结合双指针优化**，并辅以**排序**和**去重**。

1.  **预处理：排序 (Sorting)。**
    *   **重要性：** 这是 `k-Sum` 问题所有高效解决方案的基石。排序后，我们可以利用元素的有序性进行双指针扫描，并更容易地处理重复元素。
    *   **操作：** 对输入数组 `nums` 进行升序排序。

2.  **核心递归函数：`k_sum(start, end, target, k, current_combination, results)`。**
    *   **设计理念：** 将 `k-Sum` 问题分解为“选择一个元素 `x`，然后在剩余部分解决 `(k-1)-Sum` 问题，目标是 `target - x`”。
    *   **参数：**
        *   `start`, `end`：定义当前搜索的子数组范围（C++ 中使用迭代器，C 中使用索引和长度）。
        *   `target`：当前需要达成的目标和（**务必使用 `long long` 以防溢出**）。
        *   `k`：当前还需要找到的元素数量。
        *   `current_combination`：一个动态数组（C++ `vector`，C `int[]`）来存储当前已经选择的元素。
        *   `results`：一个动态数组（C++ `vector<vector<int>>`，C `int**`）来收集所有符合条件的最终组合。

3.  **递归的两种基础情况 (Base Cases)：**
    *   **剪枝/无效状态：**
        *   如果 `k < 2`（不再是 `2-Sum` 问题，或者 `k=1` 但没有剩余元素）。
        *   如果子数组的长度小于 `k`（没有足够的元素来形成组合）。
        *   如果 `k` 个元素的最坏可能和（例如，`start` 指向的最小元素 `*k` 或 `end-1` 指向的最大元素 `*k`）无法达到 `target`，可以进行激进的剪枝（可选优化）。
    *   **`k = 2` (双指针优化)：**
        *   这是递归的终点，也是效率提升的关键。
        *   使用两个指针 `left = start` 和 `right = end - 1`。
        *   在一个 `while (left < right)` 循环中：
            *   计算 `current_two_sum = *left + *right`。
            *   如果 `current_two_sum < target`，`left++`。
            *   如果 `current_two_sum > target`，`right--`。
            *   如果 `current_two_sum == target`：
                *   将 `*left` 和 `*right` 添加到 `current_combination`。
                *   将 `current_combination` 的**副本**添加到 `results`。
                *   **回溯：** 从 `current_combination` 中移除 `*left` 和 `*right`。
                *   `left++` 和 `right--`。
                *   **去重：** 在移动 `left` 和 `right` 后，跳过所有与前一个元素相同的元素，例如 `while (left < right && *left == *(left - 1)) left++;`。

4.  **递归步骤 (Recursive Step)：** `k > 2`。
    *   遍历当前子数组的每个元素 `*it` (从 `start` 到 `end - k + 1` 的范围)。
    *   **去重：** 如果 `*it` 与 `*(it - 1)` 相同，跳过当前元素（`if (it != start && *it == *(it - 1)) continue;`）。这确保了每个递归层级不会选择重复的起始元素。
    *   将 `*it` 添加到 `current_combination`。
    *   递归调用 `k_sum(it + 1, end, target - *it, k - 1, current_combination, results)`。
    *   **回溯：** 递归返回后，从 `current_combination` 中移除 `*it`（C++ `pop_back()`，C 中通过管理 `current_len` 实现）。

5.  **内存管理 (C-specific)。**
    *   如果使用 C 语言，所有动态数据结构（`results` 数组本身，以及每个 `current_combination` 的副本）都需要手动 `malloc` 和 `free`。`results` 数组需要 `realloc` 来动态扩展容量。调用者有责任 `free` 所有 `fourSum` 返回的内存。

**核心思想是：将一个复杂的高维问题（k-Sum）系统地降维成一个更容易解决的低维问题（2-Sum），并在每一步都有效地处理重复元素和内存（或容器）管理。**

### Way Of C

> source code

```c
static int compare_ints(const void *a, const void *b) {
    return (*(const int *)a - *(const int *)b);
}


static void k_sum_c(int *nums, int nums_size, int start_idx, long long target, int k,
                    int *current_combination, int current_len,
                    int ***results, int *num_results, int *max_results_capacity,
                    int **return_column_sizes, int fixed_k_val) {

    if (k < 2 || (nums_size - start_idx) < k) {
        return;
    }

    if (k == 2) {
        int left = start_idx;
        int right = nums_size - 1;

        while (left < right) {
            long long sum = (long long)nums[left] + nums[right];

            if (sum < target) {
                left++;
            } else if (sum > target) {
                right--;
            } else {
                current_combination[current_len] = nums[left];
                current_combination[current_len + 1] = nums[right];

                if (*num_results >= *max_results_capacity) {
                    *max_results_capacity = (*max_results_capacity == 0) ? 16 : (*max_results_capacity * 2);
                    *results = (int**)realloc(*results, sizeof(int*) * (*max_results_capacity));
                    *return_column_sizes = (int*)realloc(*return_column_sizes, sizeof(int) * (*max_results_capacity));
                    if (*results == NULL || *return_column_sizes == NULL) {
                        fprintf(stderr, "Error: Memory realloc failed in k_sum_c\n");
                        exit(EXIT_FAILURE);
                    }
                }

                int *final_combination = (int*)malloc(fixed_k_val * sizeof(int));
                if (final_combination == NULL) {
                    fprintf(stderr, "Error: Memory malloc failed for final_combination\n");
                    exit(EXIT_FAILURE);
                }
                memcpy(final_combination, current_combination, fixed_k_val * sizeof(int));
                (*results)[*num_results] = final_combination;
                (*return_column_sizes)[*num_results] = fixed_k_val;
                (*num_results)++;

                left++;
                while (left < right && nums[left] == nums[left - 1]) {
                    left++;
                }
                right--;
                while (left < right && nums[right] == nums[right + 1]) {
                    right--;
                }
            }
        }
        return;
    }

    for (int i = start_idx; i <= nums_size - k; ++i) {
        if (i > start_idx && nums[i] == nums[i - 1]) {
            continue;
        }

        current_combination[current_len] = nums[i];

        k_sum_c(nums, nums_size, i + 1, target - nums[i], k - 1,
                current_combination, current_len + 1,
                results, num_results, max_results_capacity,
                return_column_sizes, fixed_k_val);
    }
}

int** fourSum(int* nums, int numsSize, int target, int* returnSize, int** returnColumnSizes) {
    *returnSize = 0;
    *returnColumnSizes = NULL;
    int **results = NULL;
    int num_results = 0;
    int max_results_capacity = 0;

    if (numsSize < 4) {
        return NULL;
    }

    qsort(nums, numsSize, sizeof(int), compare_ints);

    int *current_combination = (int*)malloc(4 * sizeof(int));
    if (current_combination == NULL) {
        fprintf(stderr, "Error: Memory malloc failed for current_combination\n");
        exit(EXIT_FAILURE);
    }

    k_sum_c(nums, numsSize, 0, (long long)target, 4,
            current_combination, 0,
            &results, &num_results, &max_results_capacity,
            returnColumnSizes, 4);

    free(current_combination);

    *returnSize = num_results;

    if (num_results == 0) {
        free(results);
        free(*returnColumnSizes);
        *returnColumnSizes = NULL;
        return NULL;
    }
    
    results = (int**)realloc(results, sizeof(int*) * num_results);
    *returnColumnSizes = (int*)realloc(*returnColumnSizes, sizeof(int) * num_results);
    if (*results == NULL || *returnColumnSizes == NULL) {
         fprintf(stderr, "Error: Final realloc failed\n");
         exit(EXIT_FAILURE);
    }

    return results;
}
```

---

### Way Of C++

> source code

```c++
class Solution {
    void k_sum(vector<int>::iterator start, vector<int>::iterator end, long long target, int k, vector<int> &current_combination, vector<vector<int>> &results) {
        if (k < 2 || distance(start, end) < k) return;
        if (k == 2) {
            auto left = start;
            auto right = end - 1;
            while (left < right) {
                long long sum = (long long)*left + *right;
                if (sum < target) ++left;
                else if (sum > target) --right;
                else {
                    current_combination.push_back(*left);
                    current_combination.push_back(*right);
                    results.push_back(current_combination);
                    current_combination.pop_back();
                    current_combination.pop_back();
                    ++left;
                    while (left < right && *left == *(left - 1)) ++left;
                    --right;
                    while (left < right && *right == *(right + 1)) --right;
                }
            }
            return;
        }

        for (auto it = start; distance(it, end) >= k; ++it) {
            if (it != start && *it == *(it - 1)) continue;
            current_combination.push_back(*it);
            k_sum(it + 1, end, target - *it, k - 1, current_combination, results);

            current_combination.pop_back();
        }
    }
public:
    vector<vector<int>> fourSum(vector<int>& nums, int target) {
        vector<vector<int>> results;
        if (nums.size() < 4) return results;
        sort(nums.begin(), nums.end());
        vector<int> current_combination;
        k_sum(nums.begin(), nums.end(), (long long)target, 4, current_combination, results);
        return results;
    }
};
```
