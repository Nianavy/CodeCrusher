# Question

[wildcard-matching](https://leetcode.cn/problems/wildcard-matching/)



# Answer

> solution

解决“通配符匹配”问题，本质上是在处理 `*` 通配符的两种可能性：匹配 0 个字符或匹配 1 个或多个字符。

#### **方案一：动态规划 (DP) - C++ 示例**

这是更直观，但空间复杂度较高的方案。

1.  **第一步永远是简化数据结构。**
    *   **思想：** 使用一个二维布尔数组 `f[i][j]`，其中 `f[i][j]` 表示字符串 `s` 的前 `i` 个字符能否匹配模式 `p` 的前 `j` 个字符。
    *   **实现：** `vector<vector<bool>> f(n + 1, vector<bool>(m + 1));`

2.  **消除所有特殊情况，将它们融入通用逻辑。**
    *   **基准情况：** `f[0][0] = true` (空字符串匹配空模式)。
    *   **边界处理：** 在字符串 `s` 和模式 `p` 前添加一个虚拟字符（如空格），使得索引从 1 开始，这样 `s[i]` 就能对应 `s` 的第 `i` 个字符，`f[i-1]` 也更自然。这简化了状态转移方程的编写。
    *   **模式中只含 `*`：** `f[0][j]` 状态用于处理模式 `p` 以 `*` 开头或只包含 `*` 的情况。例如 `f[0][j] = f[0][j-1]` 如果 `p[j]` 是 `*`，表示 `*` 匹配了空字符串。

3.  **用最直接、最清晰的方式实现。**
    *   **遍历：** 嵌套循环遍历 `s` 的所有子串长度 `i` 和 `p` 的所有子模式长度 `j`。
    *   **状态转移 (`f[i][j]`)：**
        *   **如果 `p[j] == '*'`：**
            *   `f[i][j] = f[i][j-1]` ( `*` 匹配 0 个字符)
            *   `|| (i && f[i-1][j])` ( `*` 匹配 1 个或多个字符。 `i` 确保 `s` 不为空，`f[i-1][j]` 表示 `s` 的前 `i-1` 个字符已经匹配了 `p` 的前 `j` 个模式，现在 `p[j]` (即 `*`) 匹配 `s[i]`)。
        *   **如果 `p[j] == '?'` 或 `s[i] == p[j]`：**
            *   `f[i][j] = (i && f[i-1][j-1])` (当前字符匹配，且前一个子问题也匹配。 `i` 确保 `s` 不为空)。
    *   **最终结果：** `f[n][m]`。

#### **方案二：贪心（双指针带回溯） - C 语言示例**

这是空间复杂度最优 (O(1)) 的方案，但逻辑相对更复杂，需要仔细处理回溯点。

1.  **第一步永远是简化数据结构。**
    *   **思想：** 只用几个指针 (`s_ptr`, `p_ptr`) 和两个额外的标记变量 (`last_s_ptr`, `last_p_ptr`) 来记录 `*` 的回溯点。
    *   **实现：** `char *last_s = NULL; char *last_p = NULL;`

2.  **消除所有特殊情况，将它们融入通用逻辑。**
    *   **遍历 `s`：** 主循环 `while (*s_ptr != '\0')` 确保 `s` 被完全遍历。
    *   **处理 `*`：**
        *   如果 `p_ptr` 遇到 `*`，我们记录 `*` 的位置（`last_p_ptr`）和 `s` 的当前位置（`last_s_ptr`）。
        *   然后让 `*` **暂时匹配 0 个字符**，即 `p_ptr++`。这是贪心策略。
        *   如果 `*` 是模式的最后一个字符 (`*++p_ptr == '\0'`)，则直接返回 `true`。
    *   **匹配 `?` 或普通字符：** 如果 `s_ptr` 和 `p_ptr` 指向的字符匹配（包括 `p_ptr` 是 `?`），则两者都前进。
    *   **不匹配且有 `*` 回溯点：** 如果当前字符不匹配，但之前遇到过 `*` (`last_s_ptr != NULL`)，这意味着之前的贪心匹配失败了。我们需要回溯：
        *   `p_ptr` 回到 `*` 后面的位置 (`last_p_ptr`)。
        *   `s_ptr` 移动到 `last_s_ptr` 的下一个字符 (`++last_s_ptr`)，表示让 `*` 匹配 `s` 中的更多字符。
    *   **不匹配且无 `*` 回溯点：** 彻底不匹配，返回 `false`。
    *   **`s` 遍历完后：** 检查 `p` 是否还有剩余的 `*`。如果有，这些 `*` 可以匹配空序列。
    *   **最终结果：** `p_ptr` 也必须指向字符串末尾 (`*p_ptr == '\0'`) 才算完全匹配。

**总结来说，DP 方案以空间换取逻辑的直观性，适合理解和快速实现。贪心（带回溯）方案以复杂的回溯逻辑换取 O(1) 的空间复杂度，适合对内存有严格要求的场景。两种方案都有效地解决了 `*` 通配符的模糊性，是“好品味”的体现。**

### Way Of C

> source code

```c
bool isMatch(char* s, char* p)
{
    char *last_s = NULL; // 记录 's' 遇到 '*' 时的位置，用于回溯
    char *last_p = NULL; // 记录 'p' 遇到 '*' 时的后一个位置，用于回溯
    
    while (*s != '\0') { // 遍历字符串 s
        if (*p == '*') {
            // 遇到 '*'：跳过 '*'，并标记当前 s 和 p 的位置，以便后续回溯。
            // '*' 可以匹配 0 个字符，所以我们先假设它匹配 0 个，然后尝试后续匹配。
            if (*++p == '\0') { // 如果 '*' 是模式的最后一个字符，那么它能匹配 s 的任何剩余部分
                return true;
            }
            last_s = s; // 标记 s 的当前位置
            last_p = p; // 标记 '*' 后 p 的位置
        } else if (*p == '?' || *s == *p) {
            // 当前 s 和 p 字符匹配 (包括 '?' )，则同时前进
            s++;
            p++;
        } else if (last_s != NULL) {
            // 当前字符不匹配，但之前遇到过 '*'
            // 此时回溯：让 '*' 匹配 s 中的一个字符，然后从 '*' 之后的 p 继续匹配。
            p = last_p; // p 回到 '*' 后的位置
            s = ++last_s; // s 回到上次 '*' 匹配的下一个字符
        } else {
            // 当前字符不匹配，且之前没有遇到 '*'，无法匹配
            return false;
        }
    }

    // 字符串 s 已经遍历完，检查模式 p 是否还有剩余的有效字符
    while (*p == '*') { // 如果 p 剩余的都是 '*'，则匹配成功
        p++;
    }
    return *p == '\0'; // 模式 p 也必须是空，才算完全匹配
}
```

---

### Way Of C++

> source code

```c++
class Solution {
public:
    bool isMatch(string s, string p) {
        int n = s.size(), m = p.size();
        // 巧妙地在字符串前添加一个空格，使得s和p都变为1-based indexing
        // 这样f[i][j]就可以直接对应s的前i个字符和p的前j个字符
        // 优点是状态转移方程更简洁，缺点是s和p被复制，增加了O(N+M)空间和时间
        s = ' ' + s; // O(N) 复制
        p = ' ' + p; // O(M) 复制
        
        // f[i][j] 表示 s 的前 i 个字符能否匹配 p 的前 j 个字符
        vector<vector<bool>> f(n + 1, vector<bool>(m + 1));
        f[0][0] = true; // 空字符串匹配空模式

        for (int i = 0; i <= n; i ++ ) // 遍历 s 的所有子串长度
            for (int j = 1; j <= m; j ++ ) { // 遍历 p 的所有子模式长度 (p[0]是空格，所以j从1开始)
                if (p[j] == '*') {
                    // 情况1: '*' 匹配空序列。f[i][j] = f[i][j-1]
                    // 情况2: '*' 匹配一个或多个字符。f[i][j] = i && f[i-1][j]
                    // i 为 true 表示 s 不为空，可以匹配一个字符。
                    // 这里的转移方程是正确的：
                    // f[i][j-1]：'*' 匹配 0 个字符 (i个s匹配j-1个p)
                    // f[i-1][j]：'*' 匹配至少 1 个字符 (i-1个s匹配j个p，然后p[j]匹配s[i])
                    // 如果 s[i] 是空，即 i=0，则不能匹配任何字符，所以需要 i&&f[i-1][j]
                    f[i][j] = f[i][j - 1] || (i && f[i - 1][j]);
                } else {
                    // p[j] 是 '?' 或普通字符
                    // 必须满足三个条件：
                    // 1. s[i] 和 p[j] 匹配 (p[j]是'?' 或 s[i]==p[j])
                    // 2. s 不能为空 (i必须大于0，即 s[i] 存在)
                    // 3. s 的前 i-1 个字符能匹配 p 的前 j-1 个字符 (f[i-1][j-1])
                    f[i][j] = (s[i] == p[j] || p[j] == '?') && i && f[i - 1][j - 1];
                }
            }

        return f[n][m]; // 返回 s 的所有字符匹配 p 的所有模式字符的结果
    }
};
```
