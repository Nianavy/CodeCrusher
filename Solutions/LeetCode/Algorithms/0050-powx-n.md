# Question

[powx-n](https://leetcode.cn/problems/powx-n/)



# Answer

> solution

问题的核心是高效地计算 $x^n$。直接循环 $n$ 次会导致 $O(N)$ 的时间复杂度，对于大 $N$ 来说不可接受。我们需要利用**快速幂算法**（也称作二进制分解法）将其优化到 $O(\log N)$。

### 核心解决思路：快速幂 (Binary Exponentiation)

快速幂算法基于一个简单的数学原理：
*   如果 $n$ 是偶数，$x^n = (x^2)^{n/2}$
*   如果 $n$ 是奇数，$x^n = x \cdot (x^2)^{(n-1)/2}$

这个原理可以以两种方式实现：

1.  **递归法：**
    *   基准情况：当 $n=0$ 时，返回 1。
    *   递归步骤：
        *   计算 $t = x^{n/2}$。
        *   如果 $n$ 是偶数，返回 $t \cdot t$。
        *   如果 $n$ 是奇数，返回 $x \cdot t \cdot t$。

2.  **迭代法（二进制分解）：** 这是我更推荐的，因为它避免了函数调用栈的开销，通常更高效且代码更简洁。
    *   初始化结果 `res = 1`。
    *   将指数 `n` 视为二进制数。
    *   循环直到指数 `n` 变为 0：
        *   如果 `n` 的当前最低位是 1（即 `n % 2 == 1` 或 `n & 1`），则将 `res` 乘以当前的 `x`。
        *   将 `x` 平方（`x = x * x`）。
        *   将 `n` 右移一位（`n = n / 2` 或 `n >>= 1`）。

### 关键细节处理

1.  **负指数 ($n < 0$)：**
    *   如果 $n$ 是负数，我们可以将其转换为正指数和底数的倒数：$x^{-n} = (1/x)^n$。
    *   因此，首先将 $n$ 转换为其绝对值，并将 $x$ 更新为 $1/x$。

2.  **`INT_MIN` 的特殊情况：**
    *   `int` 类型的范围是 $[-2^{31}, 2^{31}-1]$。`INT_MIN` 是 $-2^{31}$。
    *   `abs(INT_MIN)` 的结果是 $2^{31}$，它超出了 `int` 的最大正值 ($2^{31}-1$)，会导致溢出，通常结果仍然是 `INT_MIN` (取决于编译器和平台，但总是未定义行为)。
    *   **解决方案：** 在进行任何绝对值操作之前，将 `n` 提升为 `long long` 类型。`long long` 可以存储 $2^{31}$。
    *   ```c++
        long long N = n; // 转换到 long long
        if (N < 0) {
            N = -N;
            x = 1.0 / x;
        }
        // 然后使用 N 进行快速幂计算
        ```

3.  **浮点数精度：**
    *   在进行浮点运算时，要意识到精度问题。例如，`1/t * 1/t` 可能会比 `1/(t*t)` 产生更多误差。尽量减少中间计算和浮点除法。
    *   题目通常允许 `double` 的默认精度。

4.  **边缘情况：**
    *   **`x = 1.0`：** 任何幂次都是 1.0。直接返回 1.0。
    *   **`x = -1.0`：** 根据 `n` 的奇偶性返回 1.0 或 -1.0。
    *   **`x = 0.0`：**
        *   `0^0` 通常定义为 1.0。
        *   `0^正数` 结果为 0.0。
        *   `0^负数` 是未定义的，在浮点运算中通常会导致无穷大 (`inf`) 或抛出异常。根据题目要求，可以不特殊处理，让 `double` 的特性来返回 `inf`。

### 总结选择迭代法的原因：

*   **性能**：避免了递归调用的栈帧开销。
*   **简洁性**：代码逻辑通常更直观，更少嵌套。
*   **可控性**：在调试和资源管理方面，迭代法更容易控制。

通过这些思路和细节处理，可以构建一个鲁棒且高效的 `myPow` 函数。

### Way Of C

> source code

```c
// 注意：C 的 abs() 函数家族：
// int abs(int);
// long labs(long);
// long long llabs(long long);
// 为了处理 long long N，最好使用 llabs。

double myPow(double x, int n) {
    // 处理特殊情况
    if (x == 1.0) return 1.0;
    if (x == -1.0) return (n % 2 == 0) ? 1.0 : -1.0;
    if (x == 0.0) return (n == 0) ? 1.0 : 0.0; 
    // 0^负数在C标准库中通常会返回 +/-inf，我们这里不特殊处理

    double res = 1.0;
    long long N = n; // 使用 long long 避免 abs(INT_MIN) 溢出

    if (N < 0) {
        N = -N;
        x = 1.0 / x; // 将负指数转换为正指数和底数的倒数
    }

    // 迭代式快速幂
    while (N > 0) {
        if (N & 1) {
            res *= x;
        }
        x *= x;
        N >>= 1;
    }

    return res;
}
```

---

### Way Of C++

> source code

```c++
class Solution {
public:
    double myPow(double x, int n) {
        // 处理特殊情况
        if (x == 1.0) return 1.0;
        if (x == -1.0) return (n % 2 == 0) ? 1.0 : -1.0;
        if (x == 0.0) return (n == 0) ? 1.0 : 0.0; // 0^0 = 1, 0^positive = 0.0
                                                // 0^negative is undefined, C++ will return inf or -inf

        double res = 1.0;
        long long N = n; // 使用 long long 避免 abs(INT_MIN) 溢出

        if (N < 0) {
            N = -N;
            x = 1.0 / x; // 将负指数转换为正指数和底数的倒数，简化后续计算
        }

        // 迭代式快速幂 (二进制分解法)
        // 循环条件 `N > 0` 比 `N` 更清晰
        while (N > 0) {
            if (N & 1) { // 如果当前位是1 (N % 2 == 1)
                res *= x;
            }
            x *= x; // 底数平方
            N >>= 1; // 指数右移一位 (N /= 2)
        }

        return res;
    }
};
```
