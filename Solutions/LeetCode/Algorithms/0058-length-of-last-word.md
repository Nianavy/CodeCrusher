# Question

[length-of-last-word](https://leetcode.cn/problems/length-of-last-word/)



# Answer

> solution

### **解决思路总结：两阶段尾部扫描法**

**格言：** “如果你只关心末尾的东西，就不要从开头浪费时间爬过来。直接从尾部开始，直到找到你需要的。”

**核心思想：**
由于我们只关心**最后一个**单词的长度，最有效的方法是从字符串的尾部开始向头部扫描。我们将整个过程分解为两个连续且不可或缺的阶段。

1.  **阶段一：跳过尾随空格 (Finding the End)**
    *   **目标：** 找到最后一个单词的右边界（即，该单词后面的第一个空格或字符串末尾）。
    *   **操作：** 从字符串的最后一个字符开始，持续向左移动索引 `i`，直到遇到第一个非空格字符，或者到达字符串的开头 (`i < 0`)。这个非空格字符的位置就是最后一个单词的实际结束位置。

2.  **阶段二：测量单词长度 (Measuring the Word)**
    *   **目标：** 计算最后一个单词的长度。
    *   **操作：** 从阶段一确定的位置开始，继续向左移动索引 `i`。在移动过程中，累加一个长度计数器。
    *   **终止条件：** 当索引 `i` 遇到一个空格字符，或者索引 `i` 降到 0 以下（到达字符串开头）时，扫描停止。

3.  **结果：**
    *   此时，长度计数器中存储的值就是最后一个单词的长度。

**实用主义的体现：**
该方法避免了从字符串开头进行复杂的单词分割和计数，直接定位到目标。这种从后向前的 O(N) 线性扫描，在平均情况下（即字符串很长但最后一个单词很短时），性能接近 O(1)，体现了极致的效率和简洁性。

### Way Of C

> source code

```c
/**
 * 计算字符串中最后一个单词的长度。
 * 采用两阶段扫描：1. 跳过尾随空格。2. 统计单词长度。
 * 时间复杂度：O(N)
 */
int lengthOfLastWord(char *s)
{
    int length = 0;
    int i = strlen(s) - 1; // 从字符串末尾开始的索引

    // 1. 跳过尾随空格
    while (i >= 0 && s[i] == ' ') {
        i--;
    }

    // 2. 统计单词长度
    while (i >= 0 && s[i] != ' ') {
        length++;
        i--;
    }

    return length;
}
```

---

### Way Of C++

> source code

```c++
class Solution {
public:
    /**
     * 计算字符串中最后一个单词的长度。
     * 采用两阶段扫描：1. 跳过尾随空格。2. 统计单词长度。
     * 时间复杂度：O(N) (最坏情况)
     */
    int lengthOfLastWord(std::string s) {
        int length = 0;
        int i = s.size() - 1;

        // 1. 跳过尾随空格
        while (i >= 0 && s[i] == ' ') {
            i--;
        }

        // 2. 统计单词长度
        while (i >= 0 && s[i] != ' ') {
            length++;
            i--;
        }

        return length;
    }
};
```
