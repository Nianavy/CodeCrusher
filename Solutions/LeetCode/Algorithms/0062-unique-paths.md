# Question

[unique-paths](https://leetcode.cn/problems/unique-paths/)



# Answer

> solution

### **解决思路总结：空间优化的动态规划 (滚动数组)**

**格言：** “不要为已经知道答案的格子浪费内存。如果你只需要上一行的信息，那就只保留上一行。”

**核心思想：**
该问题可以通过动态规划解决：到达任何一个单元格 $(i, j)$ 的唯一路径数，等于从上方单元格 $(i-1, j)$ 来的路径数，加上从左方单元格 $(i, j-1)$ 来的路径数。
$DP[i][j] = DP[i-1][j] + DP[i][j-1]$。

由于每个 $DP[i][j]$ 的计算只依赖于它的上方和左方，我们可以利用这种依赖关系进行空间优化。

1.  **空间优化：**
    *   常规 DP 需要 O(M*N) 空间。
    *   通过观察，我们只需要保留**上一行**的路径数信息。因此，我们可以使用一个一维数组 (`dp`) 来存储当前正在处理的行（或列）的路径数。
    *   为了极致优化，我们确保这个 `dp` 数组的大小是 $\min(M, N)$。

2.  **状态定义（滚动数组）：**
    *   定义一个长度为 $M$（假设 $M \le N$）的一维数组 `dp`，其中 `dp[j]` 存储的是：
        *   在当前迭代中，它代表的是上一行中单元格 $(i-1, j)$ 的路径数（即**上方**来的路径）。
        *   在被更新后，它代表的是当前行中单元格 $(i, j)$ 的路径数。

3.  **初始化：**
    *   初始化 `dp` 数组的所有元素为 1。这代表了网格的第一行（或第一列，取决于 $M, N$ 的选择）上的所有单元格，都只有一条路径可达。

4.  **状态转移 (O(M*N))：**
    *   外层循环：遍历 $N-1$ 次（从第二行开始）。
    *   内层循环：遍历 $M-1$ 次（从第二列开始）。
    *   转移方程：`dp[j] = dp[j-1] + dp[j]`。
        *   **`dp[j-1]`**：在当前迭代中，它已经更新为当前行 $(i, j-1)$ 的路径数（即**左方**来的路径）。
        *   **`dp[j]`**：在当前迭代开始时，它存储的是上一行 $(i-1, j)$ 的路径数（即**上方**来的路径）。
    *   将两者相加，就得到了当前位置 $(i, j)$ 的总路径数。

5.  **结果：**
    *   遍历结束后，最终的结果存储在 `dp` 数组的最后一个元素 `dp[m-1]` 中。

**实用主义的体现：**
该解决方案将 O(M*N) 的空间复杂度降到了 O(min(M, N))，这在处理大网格时是资源节约的关键。它利用了 DP 的局部依赖性，用最少的内存完成了计算，符合我对高效和实用主义的严格要求。

### Way Of C

> source code

```c
/**
 * 唯一路径数：动态规划 (空间优化到 O(min(m, n)))
 * 时间复杂度：O(M*N)
 * 空间复杂度：O(M) (假设 M <= N)
 */
int uniquePaths(int m, int n) {
    if (m == 0 || n == 0) {
        return 0;
    }
    
    // 如果 m > n，交换它们，确保 dp 数组的大小是较小的维度
    if (m > n) {
        int temp = m;
        m = n;
        n = temp;
    }
    // 现在 m 是较小的维度

    // 分配 O(m) 空间用于滚动数组
    int *dp = (int*)malloc(m * sizeof(int));
    if (dp == NULL) {
        return 0; // 内存分配失败
    }
    
    // 初始化第一行 (所有元素都只能通过向右走一步到达，路径数为 1)
    for (int j = 0; j < m; ++j) {
        dp[j] = 1;
    }

    // 从第二行开始遍历 (i=1 到 n-1)
    for (int i = 1; i < n; ++i) {
        // dp[0] 始终为 1 (边界条件)
        
        // 从第二列开始更新 (j=1 到 m-1)
        for (int j = 1; j < m; ++j) {
            // 状态转移方程：dp[j] = dp[j-1] + dp[j]
            // dp[j-1] 是左侧（当前行的左边）的路径数
            // dp[j] 是上方（上一行的当前位置）的路径数
            dp[j] = dp[j - 1] + dp[j];
        }
    }
    
    int result = dp[m - 1];
    free(dp); // 必须释放内存！

    return result;
}
```

---

### Way Of C++

> source code

```c++
class Solution {
public:
    /**
     * 唯一路径数：动态规划 (空间优化到 O(min(m, n)))
     * 时间复杂度：O(M*N)
     * 空间复杂度：O(M) (假设 M <= N)
     */
    int uniquePaths(int m, int n) {
        // 确保 M 总是较小的维度，以优化空间 (可选，但更优雅)
        if (m > n) {
            std::swap(m, n);
        }
        // 现在，m 是列数 (较小)，n 是行数 (较大)

        // dp 数组大小为 m，存储当前行的路径数 (只依赖于上一行和当前行的前一个元素)
        std::vector<int> dp(m, 1);

        // 从第二行开始遍历 (i=1 到 n-1)
        for (int i = 1; i < n; ++i) {
            // dp[0] 始终是 1 (边界条件)
            
            // 从第二列开始更新 (j=1 到 m-1)
            for (int j = 1; j < m; ++j) {
                // 状态转移方程：dp[j] = dp[j-1] + dp[j]
                // dp[j-1] 是当前行的左侧元素 (左边来的路径)
                // dp[j] 是上一行的当前元素 (上面来的路径)
                dp[j] = dp[j - 1] + dp[j];
            }
        }

        // 最终结果存储在 dp 数组的最后一个元素
        return dp[m - 1];
    }
};
```
