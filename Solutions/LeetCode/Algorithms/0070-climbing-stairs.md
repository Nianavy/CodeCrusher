# Question

[climbing-stairs](https://leetcode.cn/problems/climbing-stairs/)



# Answer

> solution

### **解决思路总结：斐波那契滚动数组 DP**

**格言：** “如果你只需要计算前两个状态来得到当前状态，那么整个历史状态都是垃圾。只保留你需要的。”

**核心思想：**
爬楼梯问题是一个典型的动态规划问题，因为它满足最优子结构和重叠子问题。到达第 $N$ 级台阶的方法数 $f(N)$，只能是通过以下两种方式：
1. 从第 $(N-1)$ 级台阶走 1 步上来。
2. 从第 $(N-2)$ 级台阶走 2 步上来。
因此，状态转移方程为：$$f(N) = f(N-1) + f(N-2)$$

这正是斐波那契数列的定义。

1.  **基础状态 (Base Cases)：**
    *   $f(1) = 1$ (走一步)
    *   $f(2) = 2$ (走一步+一步 或 走两步)

2.  **空间优化（滚动数组）：**
    由于计算 $f(N)$ 只需要 $f(N-1)$ 和 $f(N-2)$ 的值，我们无需存储整个 DP 数组。我们只需维护两个变量：
    *   `a`：存储 $f(i-2)$
    *   `b`：存储 $f(i-1)$

3.  **迭代计算：**
    *   初始化 `a = f(1) = 1`，`b = f(2)` 的起始状态（通常我们会将 $a, b$ 都初始化为 1，然后从 $i=2$ 或 $i=3$ 开始循环，以统一处理）。
    *   在每次迭代中，计算新的状态 `c = a + b`。
    *   然后进行状态滚动：`a = b`，`b = c`。
    *   循环执行 $N-1$ 次（从 $i=2$ 到 $N$）。

4.  **结果：**
    *   循环结束后，变量 `b` 中存储的就是最终的 $f(N)$ 值。

**实用主义的体现：**
该方法通过识别出底层的斐波那契结构，并将其转化为 O(1) 空间复杂度的迭代实现。这避免了递归的栈开销和传统 DP 的 O(N) 内存开销，达到了最高的空间效率，是解决重叠子问题 DP 的“好品味”范式。

### Way Of C

> source code

```c
/**
 * 爬楼梯问题 (斐波那契数列)：滚动数组动态规划
 * 时间复杂度：O(N)
 * 空间复杂度：O(1)
 */
int climbStairs(int n) {
    if (n <= 0) return 0;
    
    // 对于 n=1，我们直接返回 1
    if (n == 1) return 1;

    // a 存储 f(i-2)，b 存储 f(i-1)
    int a = 1; // f(1)
    int b = 1; // 理论上 f(2) 应该是 2，但循环从 i=2 开始，所以将 f(1) 赋值给 a 和 b
    
    // 循环从 i=2 开始计算 f(2), f(3), ..., f(n)
    for (int i = 2; i <= n; ++i) {
        int c = a + b; // f(i)
        a = b;         // f(i-2) 变为 f(i-1)
        b = c;         // f(i-1) 变为 f(i)
    }
    
    return b;
}
```

---

### Way Of C++

> source code

```c++
class Solution {
public:
    /**
     * 爬楼梯问题 (斐波那契数列)：滚动数组动态规划
     * f(n) = f(n-1) + f(n-2)
     * 时间复杂度：O(N)
     * 空间复杂度：O(1)
     */
    int climbStairs(int n) {
        if (n <= 0) return 0;
        
        // 约定：
        // f(0) = 1 (到达第0级台阶只有1种方法：不走)
        // f(1) = 1
        
        int a = 1; // 对应 f(i-2) 或 f(i-1)
        int b = 1; // 对应 f(i-1) 或 f(i)
        
        // n=1 时，循环不执行，返回 b=1 (正确)
        // n=2 时，循环执行 1 次：c=a+b=2, a=1, b=2。返回 b=2 (正确)
        // n=3 时，循环执行 2 次：... 最终 b=3 (正确)
        
        // 从 n=2 开始计算，需要循环 n-1 次
        for (int i = 2; i <= n; ++i) {
            int c = a + b; // 新的状态 f(i)
            a = b;         // 更新 f(i-2) 为 f(i-1)
            b = c;         // 更新 f(i-1) 为 f(i)
        }
        
        return b;
    }
};
```
